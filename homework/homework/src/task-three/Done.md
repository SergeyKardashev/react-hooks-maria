### Про мемоизацию.
Не использовал useCallback для мемоизации колбэков.
В контексте задачи с fetch запросами и  AbortController для управления асинхронными операциями, а также применением useEffect для реакции на изменения состояния, useCallback может быть полезен, если вы определяете функции внутри компонента, которые вы планируете передавать вниз по дереву компонентов или использовать их как зависимости в хуках useEffect, useMemo, useCallback. 
Однако, если такие функции не передаются в другие компоненты и не используются в списке зависимостей хуков, использование useCallback может быть необоснованным.

1. Вся логика запроса внутри кастомного хука:
- **Debounce** для поисковых запросов;
- **AbortController** для отмены запросов;
- **Управление состоянием** загрузки и данных тоже внутри хука;

2. Не происходит обращение к API при каждом вводе текста. 
Для этого использована функция debounce.
Debounce предотвращает множественные запросы к API при каждом изменении текста в инпуте. Это достигается за счёт задержки в выполнении запроса после последнего изменения текста, что позволяет снизить количество запросов к серверу. Задержка равна половине секунды.
value — это информация, которую нужно попридержать перед тем, как обработать её (тут - текст запроса)

3. Все стейты инкапсулированы внутри кастомного хука.
Стейт data хранит данные от API. Изначально это пустой массив. Заполняется после успешного запроса к API.
Стейт loading - индикатор загрузки данных. 
Стейт отложенного значения debouncedValue в useDebounce - для создания задержки. Хотя этот стайт управляется внутри хука useDebounce, стейт тесно связан с логикой запросов к API и инкапсулирован в логике кастомного хука.

4. Компонент защищен от race condition с помощью отмены запросов через abortController.
При запуске нового запроса, этот механизм отменяет предыдущие незавершенные запросы. Это защита от множественных запросов.

Как работает AbortController:
- Создание экземпляра AbortController: Перед отправкой запроса создаётся экземпляр AbortController. Этот контроллер связан с конкретным запросом через его свойство signal.
- Передача signal в запрос: Сигнал, связанный с экземпляром AbortController, передаётся в опции запроса fetch. Чтобы связать запрос с возможностью его отмены.
- Отмена предыдущего запроса: если юзер совершает новый ввод (= новый запрос), и предыдущий запрос ещё не был завершён, предыдущий запрос отменяется вызовом метода abort() на соответствующем AbortController. Это предотвращает возможность получения и обработки устаревших данных, которые могут не соответствовать текущему состоянию ввода юзера.
- Обработка ошибок отмены запроса: В catch() промиса, возвращённого фетчом, можно определить, был ли запрос отменён из-за вызова abort(), проверив, соответствует ли ошибка AbortError. Это позволяет корректно обрабатывать такие ситуации, не отображая лишние сообщения об ошибке или некорректные данные.

5. Состояние загрузки компонента отображается во время запросов и скрыто когда загрузка завершена.
